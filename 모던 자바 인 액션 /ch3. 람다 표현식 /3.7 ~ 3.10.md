# ğŸ“Œ3.7 ëŒë‹¤,ë©”ì„œë“œ ì°¸ì¡°

``` java
static class AppleComparator implements Comparator<Apple> {

        @Override
        public int compare(Apple a1, Apple a2) {
            return a1.getWeight() - a2.getWeight();
        }
    }
```
ì •ë ¬ì¡°ê±´ì„ ë„£ì–´ì¤„ë•Œ ì¼ë°˜ì ìœ¼ë¡œ 2ê°€ì§€ ë°©ë²•ë§Œ ì•Œê³  ìˆì—ˆë‹¤.
### ğŸ“˜êµ¬í˜„ì²´ + ìµëª… ê°ì²´
``` java
/** 1. êµ¬í˜„ì²´ */
inventory.sort(new AppleComparator());

 /** 2. ìµëª… ê°ì²´ */
inventory.sort(new Comparator<Apple>(){

            @Override
            public int compare(Apple a1, Apple a2) {
                return a1.getWeight() - a2.getWeight();
            }
        });
```

Comparatorì— @FunctionalInterfaceê°€ ë¶™ì–´ìˆê¸° ë•Œë¬¸ì— í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.
í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” ì˜¤ì§ í•˜ë‚˜ì˜ ì¶”ìƒë©”ì„œë“œë¥¼ ì •ì˜í•˜ëŠ” ê²ƒì´ì—ˆìœ¼ë¯€ë¡œ, í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ê¸°ëŒ€í•˜ëŠ” ê³³ì— ëŒë‹¤ í‘œí˜„ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
<br>
Comparatorì˜ í•¨ìˆ˜ ë””ìŠ¤í¬ëŸ½í„°ëŠ” `(T,T) â†’ int` ì´ë‹¤.

``` java
@FunctionalInterface
public interface Comparator<T> {

/** ë‚´ë¶€ ì •ì  ë©”ì†Œë“œ*/
public static <T, U extends Comparable<? super U>> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }
}
```
### ğŸ“˜3. ëŒë‹¤í‘œí˜„ì‹ 
``` java
inventory.sort((Apple a1,Apple a2)-> a1.getWeight()-a2.getWeight());
inventory.sort((a1,a2)-> a1.getWeight()-a2.getWeight());
```
### ğŸ“˜4. ì •ì  ë©”ì†Œë“œ ì‚¬ìš©
ìœ„ì˜ Comparator ë‚´ë¶€ì˜ ì •ì  ë©”ì†Œë“œ comparing( Function ) ì„ ì´ìš©í•œë‹¤.
``` java
Comparator<Apple> comparatorA = Comparator.comparing((Apple a)-> a.getWeight());
inventory.sort(comparatorA);

inventory.sort(comparing(apple -> apple.getWeight());
```
#### ğŸ“˜5. ë©”ì†Œë“œ ì°¸ì¡°
``` java
inventory.sort(comparing(Apple::getWeight));
```
<br>

# ğŸ“Œ3.8 ëŒë‹¤í‘œí˜„ì‹ ì¡°í•© 
### ğŸ“˜ Comparator ì¡°í•©
í•¨ìˆ˜í˜•  ì¸í„°í˜ì´ìŠ¤ëŠ” ì¶”ìƒ ë©”ì„œë“œ 1ê°œë§Œ ì œê³µí•œë‹¤.
í•˜ì§€ë§Œ ë‚´ë¶€ì˜ default ë©”ì„œë“œë¥¼ ì´ìš©í•˜ë©´ ì—¬ëŸ¬ê°œì˜ ëŒë‹¤ì‹ì„ ì¡°í•©í•  ìˆ˜ ìˆë‹¤.
( ì¶”ìƒ ë©”ì„œë“œê°€ ì•„ë‹ˆë¼ì„œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì˜ ì •ì˜ì— ë²—ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤ê³  í•œë‹¤. ) 
<br>
#### ğŸ“œComparator ë‚´ë¶€ì˜ ë””í´íŠ¸ ë©”ì„œë“œ
``` java
default Comparator<T> reversed() {
        return Collections.reverseOrder(this);
    }

default <U extends Comparable<? super U>> Comparator<T> thenComparing(
        Function<? super T, ? extends U> keyExtractor)
{
    return thenComparing(comparing(keyExtractor));
}

...
...
```
### ì˜ˆì‹œ
``` java
inventory.sort(comparing(Apple::getWeight)
         .reversed()                         <- ë¬´ê²Œë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ 
         .thenComparing(Apple::getCountry)); <- ë¬´ê²Œê°€ ê°™ìœ¼ë©´ êµ­ê°€ë³„ë¡œ ì •ë ¬ 
```
### ğŸ“˜Predicate ì¡°í•©
Predicateì˜ default ë©”ì„œë“œëŠ” ëŒ€í‘œì ìœ¼ë¡œ negate, and, orì„ ì‚¬ìš©í•œë‹¤.
``` java
@FunctionalInterface
public interface Predicate<T> {

  default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }

  default Predicate<T> negate() {
        return (t) -> !test(t);
    }

  default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }
}
```
#### ğŸ“œPredicate ì¡°í•© ì˜ˆì‹œ
``` java
 /** redApple */
Predicate<Apple> redApple = apple -> apple.getColor() == Color.RED;
List<Apple> redApples = inventory.stream()
        .filter(redApple)
        .collect(Collectors.toList());
System.out.println(redApples);    // [Apple{color=RED, weight=20}, Apple{color=RED, weight=120}]

/** NotRedApple */
Predicate<Apple> notRedApple = redApple.negate();
List<Apple> notRedApples = inventory.stream()
        .filter(notRedApple)
        .collect(Collectors.toList());
System.out.println(notRedApples); // [Apple{color=GREEN, weight=80}, Apple{color=GREEN, weight=155}]

/** Red + Weight ì œí•œ */
Predicate<Apple> redAndHeavyAppleOrGreen = redApple.and(apple -> apple.getWeight()>100)
       .or(apple -> Color.GREEN.equals(apple.getColor()));
List<Apple> redAndHeavyAppleOrGreens = inventory.stream()
        .filter(redAndHeavyAppleOrGreen)
        .collect(Collectors.toList());
System.out.println(redAndHeavyAppleOrGreens); // [Apple{color=GREEN, weight=80}, Apple{color=RED, weight=120}, Apple{color=GREEN, weight=155}]
}
```
