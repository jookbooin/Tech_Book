# ğŸ“Œ5.2 ìŠ¤íŠ¸ë¦¼ ìŠ¬ë¼ì´ì‹±

filterëŠ” Predicateë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ì„œ ì¼ì¹˜í•˜ëŠ” ëª¨ë“  ìš”ì†Œë¥¼ í¬í•¨í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ì„ ë°˜í™˜í•œë‹¤.
``` java
Stream<T> filter(Predicate<? super T> predicate);
```
filter ì—°ì‚°ì€ ì „ì²´ ìŠ¤íŠ¸ë¦¼ì„ ë°˜ë³µí•˜ë©´ì„œ ê° ìš”ì†Œì— í”„ë ˆë”” ì¼€ì´íŠ¸ë¥¼ ì ìš©í•œë‹¤.

### ğŸ“˜ TakeWhile , DropWhile
filter ì—°ì‚°ì„ íš¨ìœ¨ì ìœ¼ë¡œ í•˜ê¸°ìœ„í•´ì„œ ìŠ¤íŠ¸ë¦¼ì´ ì •ë ¬ë˜ì–´ ìˆì„ë•Œ `TakeWhile` , `DropWhile` ì„ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
* TakeWhile<br>
ì²˜ìŒìœ¼ë¡œ ê±°ì§“ì´ ë˜ëŠ” ì§€ì  ê¹Œì§€ ë°œê²¬ëœ ìš”ì†Œë¥¼ í¬í•¨í•œë‹¤.
* DropWhile<br>
ì²˜ìŒìœ¼ë¡œ ê±°ì§“ì´ ë˜ëŠ” ì§€ì  ê¹Œì§€ ë°œê²¬ëœ ìš”ì†Œë¥¼ ë²„ë¦°ë‹¤.
``` java
// ì •ë ¬ë˜ì–´ ìˆëŠ” ìƒíƒœ 
List<Dish> specialMenu = Arrays.asList(
            new Dish("season fruit", true, 120, Dish.Type.OTHER),
            new Dish("prawns", false, 300, Dish.Type.FISH),
            new Dish("rice", true, 350, Dish.Type.OTHER),
            new Dish("chicken", false, 400, Dish.Type.MEAT),
            new Dish("french fries", true, 530, Dish.Type.OTHER));

List<Dish> filteredMenu = specialMenu.stream()    
            .filter(dish -> dish.getCalories() < 320)
            .collect(toList());
filteredMenu.forEach(System.out::println);


List<Dish> slicedMenu1 = specialMenu.stream()
        .takeWhile(dish -> dish.getCalories() < 320)
        .collect(toList());
slicedMenu1.forEach(System.out::println); // [ season fruit , prawns ]


List<Dish> slicedMenu2 = specialMenu.stream()
        .dropWhile(dish -> dish.getCalories() < 320)
        .collect(toList());
slicedMenu2.forEach(System.out::println); // [ rice , chicken , french fries ]
```

# ğŸ“Œ5.3 ë§¤í•‘

* flatMap
Stream<T[]> â†’ Stream<T> ë¡œ ë³€í™˜

#### ğŸ“ƒì˜ˆì œ1
``` java
List<String> words = Arrays.asList("Hello", "World");

List<String[]> mapString = words.stream()                    // Stream<String>
                                .map(word -> word.split("")) // Stream<String[]>
                                .distinct()
                                .collect(toList());

List<Stream<String>> streamString = words.stream()                    // Stream<String>
                                         .map(word -> word.split("")) // Stream<String[]>
                                         .map(Arrays::stream)         // Stream<Stream<String>>
                                         .distinct()
                                         .collect(toList());

List<String> flatMapString = words.stream()                    // Stream<String>
                                  .map(word -> word.split("")) // Stream<String[]>
                                  .flatMap(Arrays::stream)     // Stream<String>
                                  .distinct()
                                  .collect(toList());

```

#### ğŸ“ƒì˜ˆì œ2
``` java
List<Integer> numbers1 = Arrays.asList(1,2,3,4,5);
List<Integer> numbers2 = Arrays.asList(6,7,8);
List<int[]> intArr = numbers1.stream()
        .flatMap(i -> numbers2.stream().map(j -> new int[]{i, j}))
        .collect(toList());
```
* `i -> numbers2.stream().map(j -> new int[]{i, j})` ì—ì„œ int[]íƒ€ì… Stream ë°˜í™˜ :  Stream<Stream<int[]>>
* `flatMap(i -> numbers2.stream().map(j -> new int[]{i, j}))` í‰íƒ„í™” ì§„í–‰ : Stream<int[]>

#### ğŸ“ƒì˜ˆì œ3 filter ì ìš© ìˆœì„œ 
* 1ë²ˆ<br>
ëª¨ë“  ì¡°í•©ì„ ë§Œë“¤ê³  ë‚˜ì„œì•¼ ( i + j ) % 3 == 0 ì¡°ê±´ìœ¼ë¡œ í•„í„°ë§ í•œë‹¤.
* 2ë²ˆ<br>
ìˆ«ì ìŒì„ ìƒì„±í•˜ê¸° ì „ì— í•„í„°ë§ì„ ìˆ˜í–‰í•œë‹¤.<br>
ì´ ê²½ìš°, iì™€ jì˜ í•©ì´ 3ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ëŠ”ì§€ë¥¼ í™•ì¸í•œ í›„ í•´ë‹¹í•˜ëŠ” ì¡°í•©ë§Œ ìƒì„±í•œë‹¤.

``` java
List<Integer> numbers1 = Arrays.asList(1,2,3,4,5);
List<Integer> numbers2 = Arrays.asList(6,7,8);

1. 
List<int[]> pairs = numbers1.stream()
        .flatMap(i -> numbers2.stream()
                              .map( j -> new int[]{i, j})
        )
        .filter(array -> (array[0] + array[1]) % 3 == 0)
        .collect(toList());

2.
 List<int[]> innerPairs = numbers1.stream()
            .flatMap(i -> numbers2.stream()
                                  .filter(j -> (i + j) % 3 == 0)
                                  .map(j -> new int[]{i, j}))
            .collect(toList());
```

# ğŸ“Œ5.4 ê²€ìƒ‰ ë§¤ì¹­
* anyMatch
* allMatch
* noneMatch
* findFirst
* findAny

`findFirst` ì™€ `findAny` ë©”ì„œë“œëŠ” ë³‘ë ¬ ì‹¤í–‰ì—ì„œëŠ” ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ ì°¾ê¸° ì–´ë µê¸° ë•Œë¬¸ì— í•„ìš”í•˜ë‹¤.
ìš”ì†Œì˜ ë°˜í™˜ ìˆœì„œê°€ ìƒê´€ì—†ë‹¤ë©´, ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì—ì„œëŠ” ì œì•½ì´ ì ì€ `findAny`ë¥¼ ì‚¬ìš©í•œë‹¤

# ğŸ“Œ5.5 ë¦¬ë“€ì‹±
ë¦¬ë“€ì‹± ìµœì¢…ì—°ì‚°ì€ ìŠ¤íŠ¸ë¦¼ ìš”ì†Œë¥¼ ì²˜ë¦¬í•´ì„œ ê°’ìœ¼ë¡œ ë„ì¶œí•œë‹¤.

#### ğŸ“ƒ ë°˜í™˜íƒ€ì…
* boolean (allMatch ..)
* void (foreach)
* Optional
* collect
* ê°’ (ë¦¬ë“€ì‹±)

### ğŸ“˜ reduce
ë‹¤ìŒ ì—°ì‚°ì„ reduceë¡œ í•œë²ˆì— ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.
``` java
int sum = 0;
for ( int number : numbers)
   sum += number;
```

#### ğŸ“ƒì´ˆê¸°ê°’ `(T identity)` ì¡´ì¬
``` java
T reduce(T identity, BinaryOperator<T> accumulator);

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,T,T> { }

// (T,U) â†’ R
@FunctionalInterface
public interface BiFunction<T, U, R> { }


1. Integer sum = integers.reduce(0, (a, b) -> a+b);

2.  Integer sum = integers.reduce(0, Integer::sum);

3. Integer sum = integers.reduce(1, (a, b) -> a*b);
```

#### ğŸ“ƒ ì´ˆê¸°ê°’ ì—†ìŒ
ì´ˆê¸°ê°’ì„ ë°›ì§€ ì•Šë„ë¡ ì˜¤ë²„ë¡œë“œëœ reduceì˜ ë°˜í™˜íƒ€ì…ì€ Optional ê°ì²´ë¥¼ ë°˜í™˜ë‹¤.
ì´ˆê¸°ê°’ì´ ì—†ìœ¼ë¯€ë¡œ íŠ¹ì • ê°’ìœ¼ë¡œ íŠ¹ì •í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.
``` java
Optional<T> reduce(BinaryOperator<T> accumulator);

1.Optional<Integer> sum = nubers.reduce(1, (a, b) -> a*b);
```
#### ğŸ“ƒ reduce ë©”ì„œë“œì˜ ì¥ì ê³¼ ë³‘ë ¬í™”
1. reduceë¥¼ ì´ìš©í•˜ë©´ `ë‚´ë¶€ ë°˜ë³µì´ ì¶”ìƒí™”` ë˜ë©´ì„œ, ë‚´ë¶€ êµ¬í˜„ì—ì„œ `ë³‘ë ¬`ë¡œ  reduceë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.
2. ë°˜ë³µìœ¼ë¡œ í•©ê³„ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì€ sum ë³€ìˆ˜ë¥¼ ê³µìœ í•´ì•¼í•˜ë¯€ë¡œ ë³‘ë ¬í™”ë¥¼ í•˜ê¸° ì–´ë µë‹¤.

   

